<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Local Video Grid Reviewer</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#0f172a;
      --fg:#e5e7eb;
      --muted:#94a3b8;
      --accent:#7aa2f7;
      --danger:#ef4444;
      --gap:10px;
      --radius:14px;
      --shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:linear-gradient(180deg, #0b0f14 0%, #0a0e13 60%, #0b0f14 100%);
      color:var(--fg);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow:hidden;
    }
    .toolbar{
      position:sticky; top:0; z-index:10;
      display:flex; align-items:center; gap:10px; flex-wrap:wrap;
      padding:12px 16px;
      background:rgba(15,23,42,.7);
      backdrop-filter: blur(8px) saturate(140%);
      border-bottom:1px solid rgba(148,163,184,.15);
    }
    .spacer{ flex:1; }
    .count{ color:var(--muted); font-size:14px; }
    .hint{ color:var(--muted); font-size:12px; }
    button{
      appearance:none; border:0; cursor:pointer;
      padding:10px 14px; border-radius:12px;
      background:linear-gradient(180deg, #1e293b, #111827);
      color:#e5e7eb; font-weight:600; letter-spacing:.2px;
      box-shadow: var(--shadow);
    }
    button:hover{ filter:brightness(1.05); }
    button:active{ transform:translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; }
    .btn-primary{ background:linear-gradient(180deg, #2a4b9e, #1f2b6b); }

    .visually-hidden{ position:fixed; left:-9999px; width:1px; height:1px; opacity:0; pointer-events:none; }

    #gridWrap{
      height: calc(100vh - 60px);
      padding:14px; overflow:auto;
    }
    #grid{
      display:grid; grid-auto-flow:dense;
      gap:var(--gap);
      grid-template-columns: repeat(1, 1fr);
      align-content:start;
    }
    .thumb{
      display:flex; align-items:center; justify-content:center;
      background:linear-gradient(180deg, #0f172a, #0b1222);
      border:1px solid rgba(148,163,184,.16);
      border-radius:var(--radius);
      position:relative;
      overflow:hidden;
      user-select:none;
      box-shadow: var(--shadow);
    }
    .thumb.selected{ box-shadow: 0 0 0 3px rgba(122,162,247,.65), var(--shadow); }
    .thumb.dragging{ opacity:.65; }
    .thumb.drag-over::after{ content:""; position:absolute; inset:0; border:2px dashed var(--accent); border-radius:var(--radius); pointer-events:none; }
    video{ max-width:100%; max-height:100%; width:auto; height:auto; object-fit:contain; background:black; display:block; border-radius: 10px; }
    .filename{ position:absolute; left:0; right:0; bottom:0; font-size:12px; line-height:1.3; color:#d1d5db; padding:6px 8px; background:linear-gradient(180deg, rgba(2,6,23,0), rgba(2,6,23,.75)); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

    .titles-hidden .filename{ display:none; }

    .fs-active .toolbar{ display:none; }
    .fs-active #gridWrap{ height:100vh; padding:14px; display:block; }

    /* Fullscreen tiles: pure black background, no border/shadow */
    .fs-active .thumb{ background:#000 !important; border:none !important; box-shadow:none !important; }
    .fs-active .thumb.selected{ box-shadow:none !important; }
    .fs-active .thumb.drag-over::after{ display:none !important; }

    .footerbar{ position:fixed; right:16px; bottom:16px; z-index:5; background:rgba(2,6,23,.72); border:1px solid rgba(148,163,184,.2); padding:8px 12px; border-radius:10px; color:var(--muted); font-size:12px; }
  </style>
</head>
<body>
  <header class="toolbar" id="toolbar">
    <button id="pickBtn" class="btn-primary">Browse Folder…</button>
    <input type="file" id="folderInput" class="visually-hidden" webkitdirectory directory multiple tabindex="-1" aria-hidden="true" />
    <input type="file" id="orderFileInput" class="visually-hidden" accept=".txt,text/plain" tabindex="-1" aria-hidden="true" />
    <button id="loadOrderBtn" title="Load an order file (clip-order.txt)">Load Order…</button>
    <button id="saveBtn" title="Save clip-order.txt in the chosen folder (or download if permissions are unavailable)" disabled>Save Order</button>
    <button id="toggleTitlesBtn" title="Hide or show clip titles">Hide Titles</button>
    <button id="fsBtn" title="Full screen (hides titles)">Full Screen</button>
    <div class="spacer"></div>
    <span class="count" id="count">0 clips</span>
    <span class="hint">drag to reorder • click to select • press Delete to remove • press F for fullscreen</span>
  </header>

  <div id="gridWrap">
    <div id="grid" aria-live="polite"></div>
  </div>

  <div class="footerbar" id="status" hidden></div>

  <script>
  (()=>{
  'use strict';

  const pickBtn = document.getElementById('pickBtn');
  const saveBtn = document.getElementById('saveBtn');
  const folderInput = document.getElementById('folderInput');
  const orderFileInput = document.getElementById('orderFileInput');
  const loadOrderBtn = document.getElementById('loadOrderBtn');
  const grid = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const countSpan = document.getElementById('count');
  const toolbar = document.getElementById('toolbar');
  const statusBar = document.getElementById('status');
  const toggleTitlesBtn = document.getElementById('toggleTitlesBtn');
  const fsBtn = document.getElementById('fsBtn');
  const body = document.body;

  let currentDirHandle = null;
  let selectedThumb = null;
  let dragSourceId = null;
  let idCounter = 0;

  // --- Fullscreen layout lock & randomizer state ---
  let lastLayout = null;   // { cols, cellH }
  let layoutLock = null;   // when set, computeGrid keeps exact cols/height
  let fsSlots = 12;        // total slots in fullscreen (last slot empty)
  let fsHidden = [];       // elements hidden in fullscreen
  let fsDigitBuffer = '';
  let fsDigitTimer = null;
  let fsRandInterval = null;
  let fsRandPending = false;

  const VIDEO_EXTS = new Set(['mp4','m4v','mov','webm','ogv','avi','mkv','mpg','mpeg']);

  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));
  const niceNum = (n)=> new Intl.NumberFormat().format(n);

  function isVideoFile(file){
    if (file.type && file.type.startsWith('video/')) return true;
    const name = file.name || '';
    const ext = name.split('.').pop().toLowerCase();
    return VIDEO_EXTS.has(ext);
  }

  function showStatus(msg, timeout=2500){
    statusBar.textContent = msg; statusBar.hidden=false;
    clearTimeout(showStatus._t);
    showStatus._t = setTimeout(()=> statusBar.hidden = true, timeout);
  }

  function updateCount(){
    const n = grid.children.length;
    countSpan.textContent = n === 1 ? '1 clip' : `${niceNum(n)} clips`;
    saveBtn.disabled = n === 0;
  }

  function clearGrid(){
    for (const el of Array.from(grid.children)){
      const url = el.dataset.objectUrl;
      if (url) URL.revokeObjectURL(url);
    }
    grid.innerHTML = '';
    selectedThumb = null;
    updateCount();
  }

  function inTopLevelWindow(){ try{ return window.top === window.self; }catch{ return false; } }
  function canUseDirectoryPicker(){ return !!(window.isSecureContext && inTopLevelWindow() && 'showDirectoryPicker' in window); }

  async function pickFolder(){
    clearGrid();
    if (canUseDirectoryPicker()){
      try{
        currentDirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
        const files = [];
        for await (const entry of currentDirHandle.values()){
          if (entry.kind === 'file'){
            try{ const file = await entry.getFile(); if (isVideoFile(file)) files.push(file); }catch{}
          }
        }
        files.sort((a,b)=> a.name.localeCompare(b.name, undefined, { numeric:true, sensitivity:'base' }));
        if (files.length === 0) showStatus('No video files found in the selected folder.');
        await loadFiles(files);
        return;
      }catch(err){ console.warn('Directory picker unavailable, falling back.', err); }
    }
    try{ if (typeof folderInput.showPicker === 'function') folderInput.showPicker(); else folderInput.click(); }
    catch{ folderInput.click(); }
  }

  async function loadFiles(fileList){
    const arr = Array.from(fileList).filter(isVideoFile);
    if (arr.length === 0){ updateCount(); computeGrid(); return; }
    for (const file of arr){ addThumbForFile(file); }
    updateCount();
    await sleep(20);
    computeGrid();
    showStatus(`Loaded ${arr.length} video${arr.length===1?'':'s'}.`);
  }

  function addThumbForFile(file){
    const id = `vid_${++idCounter}`;
    const url = URL.createObjectURL(file);

    const card = document.createElement('div');
    card.className = 'thumb'; card.tabIndex = 0; card.id = id; card.draggable = true;
    card.dataset.name = file.name; card.dataset.objectUrl = url;

    const vid = document.createElement('video');
    vid.src = url; vid.loop = true; vid.autoplay = true; vid.muted = true; vid.playsInline = true; vid.preload = 'metadata';
    vid.addEventListener('canplay', ()=>{ vid.play().catch(()=>{}); }, { once:true });

    const name = document.createElement('div');
    name.className = 'filename'; name.title = file.name; name.textContent = file.name;

    card.appendChild(vid); card.appendChild(name); grid.appendChild(card);

    card.addEventListener('click', ()=>{
      if (selectedThumb && selectedThumb !== card) selectedThumb.classList.remove('selected');
      selectedThumb = card; card.classList.toggle('selected');
      if (!card.classList.contains('selected')) selectedThumb = null;
    });

    card.addEventListener('dragstart', (e)=>{
      dragSourceId = card.id; card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', card.id);
    });
    card.addEventListener('dragend', ()=>{ card.classList.remove('dragging'); dragSourceId = null; removeDragOverClasses(); });
    card.addEventListener('dragover', (e)=>{ e.preventDefault(); const t=e.currentTarget; if (!dragSourceId||t.id===dragSourceId) return; t.classList.add('drag-over'); });
    card.addEventListener('dragleave', (e)=> e.currentTarget.classList.remove('drag-over'));
    card.addEventListener('drop', (e)=>{
      e.preventDefault(); const t=e.currentTarget; t.classList.remove('drag-over');
      const srcId = e.dataTransfer.getData('text/plain') || dragSourceId; const srcEl = document.getElementById(srcId);
      if (!srcEl || srcEl===t) return; const rect=t.getBoundingClientRect(); const before=(e.clientY-rect.top)<rect.height/2;
      if (before) grid.insertBefore(srcEl, t); else grid.insertBefore(srcEl, t.nextSibling); computeGrid();
    });
  }

  function removeDragOverClasses(){ for (const el of grid.children){ el.classList.remove('drag-over'); } }

  function computeGrid(){
    if (layoutLock){ grid.style.gridTemplateColumns = `repeat(${layoutLock.cols}, 1fr)`; for (const el of grid.children){ el.style.height = `${layoutLock.cellH}px`; } return; }
    const n = grid.children.length; if (n === 0){ grid.style.gridTemplateColumns = 'repeat(1, 1fr)'; return; }
    const wrapStyles = getComputedStyle(grid); const gap = parseFloat(wrapStyles.gap) || 0;
    const toolbarRect = toolbar.getBoundingClientRect(); const availW = gridWrap.clientWidth; const availH = window.innerHeight - Math.ceil(toolbarRect.height) - 28; if (availW<=0||availH<=0) return;
    let best = { cols:1, rows:n, area:0, cellW:availW, cellH:Math.max(80, (availH - gap*(n-1))/n) };
    for (let cols=1; cols<=n; cols++){ const rows=Math.ceil(n/cols); const cellW=(availW - gap*(cols-1))/cols; const cellH=(availH - gap*(rows-1))/rows; if (cellW<=0||cellH<=0) continue; const area=cellW*cellH; if (area>best.area) best={ cols, rows, area, cellW, cellH }; }
    grid.style.gridTemplateColumns = `repeat(${best.cols}, 1fr)`; for (const el of grid.children){ el.style.height = `${best.cellH}px`; }
    lastLayout = { cols: best.cols, cellH: best.cellH };
  }

  function getOrderArray(){ return Array.from(grid.children).map(el=>el.dataset.name).filter(Boolean); }
  function applyOrder(names){ const map=new Map(); Array.from(grid.children).forEach(el=>map.set(el.dataset.name, el)); const frag=document.createDocumentFragment(); for (const n of names){ const el=map.get(n); if (el) frag.appendChild(el); } grid.appendChild(frag); computeGrid(); showStatus('Order applied.'); }
  function validateAndApplyOrderStrict(lines){
    const order = lines.map(s=>s.trim()).filter(Boolean);
    const current = getOrderArray();
    const issues = [];
    const counts = new Map(); for (const n of order){ counts.set(n, (counts.get(n)||0)+1); }
    const dups = Array.from(counts.entries()).filter(([,c])=>c>1).map(([n,c])=>`${n} (x${c})`);
    if (dups.length) issues.push(`Duplicate entries in order file:\n- ${dups.join('\n- ')}`);
    const setOrder=new Set(order), setCurrent=new Set(current);
    const missing = current.filter(n=>!setOrder.has(n));
    const extras  = order.filter(n=>!setCurrent.has(n));
    if (missing.length) issues.push(`Missing filenames (present in grid but not in file):\n- ${missing.join('\n- ')}`);
    if (extras.length)  issues.push(`Unknown filenames (present in file but not loaded):\n- ${extras.join('\n- ')}`);
    if (setOrder.size !== setCurrent.size) issues.push(`Count mismatch: grid has ${setCurrent.size} unique clips, file lists ${setOrder.size}.`);
    if (issues.length){ alert('Could not apply order due to the following issues:\n\n' + issues.join('\n\n')); return; }
    applyOrder(order);
  }

  async function saveOrder(){
    const names = Array.from(grid.children).map(el => el.dataset.name || '').filter(Boolean);
    const text = names.join('\n') + '\n';
    if (currentDirHandle && currentDirHandle.kind === 'directory' && currentDirHandle.getFileHandle){
      try{ const fh = await currentDirHandle.getFileHandle('clip-order.txt', { create:true }); const writable = await fh.createWritable(); await writable.write(text); await writable.close(); showStatus('Saved clip-order.txt to the selected folder.'); return; }
      catch(err){ console.warn('Direct save failed, falling back to download.', err); }
    }
    const blob = new Blob([text], { type: 'text/plain' }); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='clip-order.txt'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=> URL.revokeObjectURL(a.href), 1000); showStatus('Downloaded clip-order.txt.');
  }

  function setTitlesHidden(hidden){ body.classList.toggle('titles-hidden', hidden); toggleTitlesBtn.textContent = hidden ? 'Show Titles' : 'Hide Titles'; }

  let savedTitleHiddenForFS = null;
  async function enterFullScreen(){ try{ savedTitleHiddenForFS = body.classList.contains('titles-hidden'); setTitlesHidden(true); const el=document.documentElement; if (el.requestFullscreen) await el.requestFullscreen(); else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen(); fsBtn.textContent='Exit Full Screen'; computeGrid(); }catch(e){ console.warn(e); } }
  async function exitFullScreen(){ try{ if (document.exitFullscreen) await document.exitFullscreen(); else if (document.webkitExitFullscreen) document.webkitExitFullscreen(); }catch(e){ console.warn(e); } }

  function isFullscreen(){ return !!(document.fullscreenElement || document.webkitFullscreenElement); }
  function onGlobalKeyDown(e){
    if (e.altKey || e.ctrlKey || e.metaKey) return;
    const key = e.key;
    if (key==='f' || key==='F'){ if (!isFullscreen()) enterFullScreen(); else exitFullScreen(); e.preventDefault(); return; }
    if (!isFullscreen()) return;
    if (key >= '0' && key <= '9'){
      fsDigitBuffer += key; clearTimeout(fsDigitTimer);
      fsDigitTimer = setTimeout(()=>{ const v=parseInt(fsDigitBuffer,10); fsDigitBuffer=''; if (!Number.isNaN(v)){ fsSlots=Math.max(2,v); fsApplySlots(); showStatus('Fullscreen slots: '+fsSlots+' (showing '+Math.max(0,fsSlots-1)+')', 1500); } }, 600);
      e.preventDefault(); return;
    }
  }

  function onKeyDown(e){
    if (!selectedThumb) return;
    if (e.key === 'Delete' || e.key === 'Backspace'){
      const toRemove = selectedThumb; selectedThumb = null; URL.revokeObjectURL(toRemove.dataset.objectUrl); toRemove.remove(); updateCount(); computeGrid(); showStatus('Clip removed from view.'); e.preventDefault();
    }
  }

  pickBtn.addEventListener('click', pickFolder);
  folderInput.addEventListener('change', (e)=>{ currentDirHandle = null; clearGrid(); loadFiles(e.target.files); });
  saveBtn.addEventListener('click', saveOrder);

  loadOrderBtn.addEventListener('click', ()=>{ if (typeof orderFileInput.showPicker === 'function') orderFileInput.showPicker(); else orderFileInput.click(); });
  orderFileInput.addEventListener('change', (e)=>{ const f=e.target.files && e.target.files[0]; if (f){ f.text().then(t=>{ const lines=t.replace(/\r/g,'').split('\n'); validateAndApplyOrderStrict(lines); }).catch(err=> alert('Failed to read order file: ' + (err?.message || err))); } e.target.value=''; });

  toggleTitlesBtn.addEventListener('click', ()=> setTitlesHidden(!body.classList.contains('titles-hidden')));
  fsBtn.addEventListener('click', ()=>{ if (!isFullscreen()) enterFullScreen(); else exitFullScreen(); });

  function fsComputeAndApplyGrid(){
    // Compute rows/cols from the desired fullscreen slot count to FILL the screen
    const N = Math.max(2, fsSlots); // total slots (we'll still leave one empty)
    const gap = parseFloat(getComputedStyle(grid).gap) || 0;
    const availW = gridWrap.clientWidth;
    const availH = window.innerHeight - 28; // account for padding
    let best = { rows:1, cols:N, area:0, cellH:120 };
    for (let rows=1; rows<=N; rows++){
      const cols = Math.ceil(N / rows);
      const cellW = (availW - gap*(cols-1)) / cols;
      const cellH = (availH - gap*(rows-1)) / rows;
      if (cellW <= 0 || cellH <= 0) continue;
      const area = cellW * cellH;
      if (area > best.area) best = { rows, cols, area, cellH };
    }
    grid.style.gridTemplateColumns = `repeat(${best.cols}, 1fr)`;
    for (const el of grid.children){ el.style.height = `${best.cellH}px`; }
    return best;
  }
  function fsApplySlots(){
    // No layout lock: we recompute to fill the screen each time
    if (fsHidden.length){ fsHidden.forEach(el=> el.style.display=''); fsHidden = []; }
    const best = fsComputeAndApplyGrid();
    const children = Array.from(grid.children);
    const total = children.length;
    if (total === 0) return;
    const targetVisible = Math.max(1, Math.min(total, best.rows * best.cols - 1)); // keep last slot empty
    let toHide = Math.max(0, total - targetVisible);
    for (let i=0; i<total; i++){
      const el = children[i];
      if (i === total - 1){ el.style.display=''; continue; } // never hide last
      if (toHide > 0){ el.style.display='none'; fsHidden.push(el); toHide--; }
      else { el.style.display=''; }
    }
  }

function fsRestoreAndUnlock(){ if (fsHidden.length){ fsHidden.forEach(el=> el.style.display=''); fsHidden=[]; } layoutLock=null; }

  function startFsRandomizer(){ if (fsRandInterval) return; fsRandInterval = setInterval(()=>{ if (isFullscreen()) randomizeOnce(); }, 3000); }
  function stopFsRandomizer(){ if (fsRandInterval){ clearInterval(fsRandInterval); fsRandInterval=null; } fsRandPending=false; }
  function currentVisibleCards(){ return Array.from(grid.children).filter(el=> el.style.display !== 'none'); }
  function currentHiddenCards(){ return Array.from(grid.children).filter(el=> el.style.display === 'none'); }
  function waitForEnd(vid){ return new Promise(res=>{ const h=()=>{ vid.removeEventListener('ended', h); res(); }; vid.addEventListener('ended', h, { once:true }); }); }
  function swapCardContents(a, b){
    const va=a.querySelector('video'), vb=b.querySelector('video');
    const na=a.dataset.name, nb=b.dataset.name; const ua=a.dataset.objectUrl, ub=b.dataset.objectUrl;
    a.dataset.name=nb; b.dataset.name=na; a.dataset.objectUrl=ub; b.dataset.objectUrl=ua;
    const fa=a.querySelector('.filename'), fb=b.querySelector('.filename'); fa.textContent=nb; fa.title=nb; fb.textContent=na; fb.title=na;
    va.pause(); vb.pause(); va.src=ub; vb.src=ua; va.loop=true; vb.loop=true; va.muted=true; vb.muted=true; va.play().catch(()=>{});
  }
  function randomizeOnce(){
    if (!isFullscreen() || fsRandPending) return;
    const vis=currentVisibleCards(); const hid=currentHiddenCards();
    if (vis.length<=1 || hid.length===0) return;
    const maxIndex = vis.length - 1; const idx=Math.floor(Math.random()*(maxIndex+1));
    const targetCard=vis[idx]; const replCard=hid[Math.floor(Math.random()*hid.length)];
    const v=targetCard.querySelector('video'); fsRandPending=true; v.loop=false;
    waitForEnd(v).then(()=>{ swapCardContents(targetCard, replCard); replCard.style.display='none'; targetCard.style.display=''; const v2=targetCard.querySelector('video'); v2.loop=true; v2.play().catch(()=>{}); }).catch(()=>{}).finally(()=>{ fsRandPending=false; });
  }

  function onFsChange(){
    const active = isFullscreen(); body.classList.toggle('fs-active', active);
    if (!active){ fsRestoreAndUnlock(); stopFsRandomizer(); if (savedTitleHiddenForFS!==null){ setTitlesHidden(savedTitleHiddenForFS); savedTitleHiddenForFS=null; } fsBtn.textContent='Full Screen'; }
    else { fsApplySlots(); startFsRandomizer(); fsBtn.textContent='Exit Full Screen'; }
    computeGrid();
  }
  document.addEventListener('fullscreenchange', onFsChange);
  document.addEventListener('webkitfullscreenchange', onFsChange);

  window.addEventListener('resize', ()=>{ if (isFullscreen()) fsApplySlots(); else computeGrid(); });
  document.addEventListener('keydown', onKeyDown);
  document.addEventListener('keydown', onGlobalKeyDown);

  updateCount();
  computeGrid();
  setTitlesHidden(false);
  })();
  </script>
</body>
</html>
